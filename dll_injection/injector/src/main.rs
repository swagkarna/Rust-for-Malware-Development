use std::env::args;
use std::ffi::CString;
use std::ptr::null_mut;
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};
use winapi::um::libloaderapi::{GetModuleHandleA, GetProcAddress};
use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory, VirtualFreeEx};
use winapi::um::processthreadsapi::{CreateRemoteThread, OpenProcess, TerminateThread, GetExitCodeThread};
use winapi::um::synchapi::WaitForSingleObject;
use winapi::um::winnt::{MEM_COMMIT, MEM_RESERVE, PAGE_EXECUTE_READWRITE, PROCESS_ALL_ACCESS, MEM_RELEASE};
use winapi::um::winbase::INFINITE;
use winapi::shared::ntdef::NULL;
use winapi::ctypes::c_void;

macro_rules! log {
    ($level:expr, $msg:expr) => {{
        let color = match $level {
            "DEBUG" => "\x1b[94m", 
            "INFO" => "\x1b[32m",  
            "WARN" => "\x1b[33m",  
            "ERROR" => "\x1b[31m", 
            _ => "\x1b[0m",        
        };

        match $level{
            "DEBUG" => println!("{}[||] {}\x1b[0m", color, $msg),
            "INFO" => println!("{}[+] {}\x1b[0m", color, $msg),
            "WARN" => println!("{}[!] {}\x1b[0m", color, $msg),
            "ERROR" => println!("{}[-] {}\x1b[0m", color, $msg),
            _ => println!("{}{}\x1b[0m", color,$msg),
        };
    }};
}

fn main() {
    let args: Vec<String> = args().collect();
    if args.len() != 3 {
        log!("ERROR", "Usage: dll_inject.exe <PID> <DLL Path>");
        return;
    }

    let pid: u32 = args[1].parse().expect("Provide a valid PID");
    let dll_path = CString::new(&*args[2]).expect("Failed to convert DLL path to CString");

    log!("INFO", format!("PID: {}", pid));
    log!("INFO", format!("DLL Path: {}", dll_path.to_str().unwrap()));

    unsafe {
        let process = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
        if process == NULL {
            log!("ERROR", format!("Failed to get handle to the process: Error Code {}", GetLastError()));
            return;
        }

        log!("INFO", format!("HANDLE of {}: {:?}", pid, process));

        let buffer = VirtualAllocEx(
            process,
            null_mut(),
            dll_path.as_bytes().len(),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE,
        );

        if buffer == null_mut() {
            log!("ERROR", format!("Failed to allocate buffer: Error Code {}", GetLastError()));
            CloseHandle(process);
            return;
        }

        log!("INFO", format!("Buffer Allocated: {:#?}", buffer));

        let mut bytes_written = 0;
        if WriteProcessMemory(
            process,
            buffer,
            dll_path.as_ptr() as *const c_void,
            dll_path.as_bytes().len(),
            &mut bytes_written,
        ) == 0 {
            log!("ERROR", format!("Failed to write DLL path to process memory: Error Code {}", GetLastError()));
            VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
            CloseHandle(process);
            return;
        }

        log!("INFO", "Wrote DLL path to process memory!");

        let kernel32 = GetModuleHandleA(b"kernel32.dll\0".as_ptr() as *const i8);
        if kernel32 == null_mut() {
            log!("ERROR", format!("Failed to get handle to kernel32.dll: Error Code {}", GetLastError()));
            VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
            CloseHandle(process);
            return;
        }

        log!("INFO", format!("Got handle to kernel32.dll: {:#?}", kernel32));

        let load_library_addr = GetProcAddress(kernel32, b"LoadLibraryA\0".as_ptr() as *const i8);
        if load_library_addr.is_null() {
            log!("ERROR", format!("Failed to get address of LoadLibraryA: Error Code {}", GetLastError()));
            VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
            CloseHandle(process);
            return;
        }

        log!("INFO", format!("LoadLibraryA Address: {:#?}", load_library_addr));

        let thread = CreateRemoteThread(
            process,
            null_mut(),
            0,
            Some(std::mem::transmute(load_library_addr)),
            buffer,
            0,
            null_mut(),
        );

        if thread == INVALID_HANDLE_VALUE {
            log!("ERROR", format!("Failed to create remote thread: Error Code {}", GetLastError()));
            VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
            CloseHandle(process);
            return;
        }

        log!("INFO", format!("Remote thread created: {:#?}", thread));

        WaitForSingleObject(thread, INFINITE);

        let mut exit_code = 0;
        GetExitCodeThread(thread, &mut exit_code);
        if exit_code == STILL_ACTIVE {
            log!("INFO", "Thread is still active, terminating it.");
            TerminateThread(thread, 0);
        }

        log!("INFO", "DLL Injection executed successfully!");

        VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
        CloseHandle(thread);
        CloseHandle(process);
    }
}

const STILL_ACTIVE: u32 = 259;